// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum TimeIntervalType {
  Closed = 0,
  Open = 1,
  LeftHalfOpen = 2,
  RightHalfOpen = 3,
  UnboundedClosedRight = 4,
  UnboundedOpenRight = 5,
  UnboundedClosedLeft = 6,
  UnboundedOpenLeft = 7,
  Singleton = 8,
  Unbounded = 9,
  Empty = 10,

}

pub const ENUM_MIN_TIME_INTERVAL_TYPE: u8 = 0;
pub const ENUM_MAX_TIME_INTERVAL_TYPE: u8 = 10;

impl<'a> flatbuffers::Follow<'a> for TimeIntervalType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for TimeIntervalType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const TimeIntervalType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const TimeIntervalType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for TimeIntervalType {
    type Output = TimeIntervalType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<TimeIntervalType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TIME_INTERVAL_TYPE:[TimeIntervalType; 11] = [
  TimeIntervalType::Closed,
  TimeIntervalType::Open,
  TimeIntervalType::LeftHalfOpen,
  TimeIntervalType::RightHalfOpen,
  TimeIntervalType::UnboundedClosedRight,
  TimeIntervalType::UnboundedOpenRight,
  TimeIntervalType::UnboundedClosedLeft,
  TimeIntervalType::UnboundedOpenLeft,
  TimeIntervalType::Singleton,
  TimeIntervalType::Unbounded,
  TimeIntervalType::Empty
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_TIME_INTERVAL_TYPE:[&'static str; 11] = [
    "Closed",
    "Open",
    "LeftHalfOpen",
    "RightHalfOpen",
    "UnboundedClosedRight",
    "UnboundedOpenRight",
    "UnboundedClosedLeft",
    "UnboundedOpenLeft",
    "Singleton",
    "Unbounded",
    "Empty"
];

pub fn enum_name_time_interval_type(e: TimeIntervalType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_TIME_INTERVAL_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum EventTimeSource {
  NONE = 0,
  EventTimeSourceFromMetadata = 1,
  EventTimeSourceFromPath = 2,

}

pub const ENUM_MIN_EVENT_TIME_SOURCE: u8 = 0;
pub const ENUM_MAX_EVENT_TIME_SOURCE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for EventTimeSource {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for EventTimeSource {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const EventTimeSource;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const EventTimeSource;
    unsafe { *p }
  }
}

impl flatbuffers::Push for EventTimeSource {
    type Output = EventTimeSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<EventTimeSource>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TIME_SOURCE:[EventTimeSource; 3] = [
  EventTimeSource::NONE,
  EventTimeSource::EventTimeSourceFromMetadata,
  EventTimeSource::EventTimeSourceFromPath
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_EVENT_TIME_SOURCE:[&'static str; 3] = [
    "NONE",
    "EventTimeSourceFromMetadata",
    "EventTimeSourceFromPath"
];

pub fn enum_name_event_time_source(e: EventTimeSource) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_EVENT_TIME_SOURCE[index as usize]
}

pub struct EventTimeSourceUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SourceCaching {
  NONE = 0,
  SourceCachingForever = 1,

}

pub const ENUM_MIN_SOURCE_CACHING: u8 = 0;
pub const ENUM_MAX_SOURCE_CACHING: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for SourceCaching {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SourceCaching {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const SourceCaching;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const SourceCaching;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SourceCaching {
    type Output = SourceCaching;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SourceCaching>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_CACHING:[SourceCaching; 2] = [
  SourceCaching::NONE,
  SourceCaching::SourceCachingForever
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_SOURCE_CACHING:[&'static str; 2] = [
    "NONE",
    "SourceCachingForever"
];

pub fn enum_name_source_caching(e: SourceCaching) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_SOURCE_CACHING[index as usize]
}

pub struct SourceCachingUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i32)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SourceOrdering {
  ByEventTime = 0,
  ByName = 1,

}

pub const ENUM_MIN_SOURCE_ORDERING: i32 = 0;
pub const ENUM_MAX_SOURCE_ORDERING: i32 = 1;

impl<'a> flatbuffers::Follow<'a> for SourceOrdering {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SourceOrdering {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i32::to_le(self as i32);
    let p = &n as *const i32 as *const SourceOrdering;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i32::from_le(self as i32);
    let p = &n as *const i32 as *const SourceOrdering;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SourceOrdering {
    type Output = SourceOrdering;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SourceOrdering>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_ORDERING:[SourceOrdering; 2] = [
  SourceOrdering::ByEventTime,
  SourceOrdering::ByName
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_SOURCE_ORDERING:[&'static str; 2] = [
    "ByEventTime",
    "ByName"
];

pub fn enum_name_source_ordering(e: SourceOrdering) -> &'static str {
  let index = e as i32;
  ENUM_NAMES_SOURCE_ORDERING[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FetchStep {
  NONE = 0,
  FetchStepUrl = 1,
  FetchStepFilesGlob = 2,

}

pub const ENUM_MIN_FETCH_STEP: u8 = 0;
pub const ENUM_MAX_FETCH_STEP: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FetchStep {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FetchStep {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FetchStep;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FetchStep;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FetchStep {
    type Output = FetchStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FetchStep>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FETCH_STEP:[FetchStep; 3] = [
  FetchStep::NONE,
  FetchStep::FetchStepUrl,
  FetchStep::FetchStepFilesGlob
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FETCH_STEP:[&'static str; 3] = [
    "NONE",
    "FetchStepUrl",
    "FetchStepFilesGlob"
];

pub fn enum_name_fetch_step(e: FetchStep) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FETCH_STEP[index as usize]
}

pub struct FetchStepUnionTableOffset {}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(i32)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum CompressionFormat {
  Gzip = 0,
  Zip = 1,

}

pub const ENUM_MIN_COMPRESSION_FORMAT: i32 = 0;
pub const ENUM_MAX_COMPRESSION_FORMAT: i32 = 1;

impl<'a> flatbuffers::Follow<'a> for CompressionFormat {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for CompressionFormat {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i32::to_le(self as i32);
    let p = &n as *const i32 as *const CompressionFormat;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i32::from_le(self as i32);
    let p = &n as *const i32 as *const CompressionFormat;
    unsafe { *p }
  }
}

impl flatbuffers::Push for CompressionFormat {
    type Output = CompressionFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CompressionFormat>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPRESSION_FORMAT:[CompressionFormat; 2] = [
  CompressionFormat::Gzip,
  CompressionFormat::Zip
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_COMPRESSION_FORMAT:[&'static str; 2] = [
    "Gzip",
    "Zip"
];

pub fn enum_name_compression_format(e: CompressionFormat) -> &'static str {
  let index = e as i32;
  ENUM_NAMES_COMPRESSION_FORMAT[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum PrepStep {
  NONE = 0,
  PrepStepDecompress = 1,
  PrepStepPipe = 2,

}

pub const ENUM_MIN_PREP_STEP: u8 = 0;
pub const ENUM_MAX_PREP_STEP: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for PrepStep {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for PrepStep {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const PrepStep;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const PrepStep;
    unsafe { *p }
  }
}

impl flatbuffers::Push for PrepStep {
    type Output = PrepStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<PrepStep>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PREP_STEP:[PrepStep; 3] = [
  PrepStep::NONE,
  PrepStep::PrepStepDecompress,
  PrepStep::PrepStepPipe
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_PREP_STEP:[&'static str; 3] = [
    "NONE",
    "PrepStepDecompress",
    "PrepStepPipe"
];

pub fn enum_name_prep_step(e: PrepStep) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_PREP_STEP[index as usize]
}

pub struct PrepStepUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ReadStep {
  NONE = 0,
  ReadStepCsv = 1,
  ReadStepJsonLines = 2,
  ReadStepGeoJson = 3,
  ReadStepEsriShapefile = 4,

}

pub const ENUM_MIN_READ_STEP: u8 = 0;
pub const ENUM_MAX_READ_STEP: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for ReadStep {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ReadStep {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const ReadStep;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const ReadStep;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ReadStep {
    type Output = ReadStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ReadStep>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_READ_STEP:[ReadStep; 5] = [
  ReadStep::NONE,
  ReadStep::ReadStepCsv,
  ReadStep::ReadStepJsonLines,
  ReadStep::ReadStepGeoJson,
  ReadStep::ReadStepEsriShapefile
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_READ_STEP:[&'static str; 5] = [
    "NONE",
    "ReadStepCsv",
    "ReadStepJsonLines",
    "ReadStepGeoJson",
    "ReadStepEsriShapefile"
];

pub fn enum_name_read_step(e: ReadStep) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_READ_STEP[index as usize]
}

pub struct ReadStepUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Transform {
  NONE = 0,
  TransformSql = 1,

}

pub const ENUM_MIN_TRANSFORM: u8 = 0;
pub const ENUM_MAX_TRANSFORM: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for Transform {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Transform {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Transform;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Transform;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Transform>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM:[Transform; 2] = [
  Transform::NONE,
  Transform::TransformSql
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_TRANSFORM:[&'static str; 2] = [
    "NONE",
    "TransformSql"
];

pub fn enum_name_transform(e: Transform) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_TRANSFORM[index as usize]
}

pub struct TransformUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum MergeStrategy {
  NONE = 0,
  MergeStrategyAppend = 1,
  MergeStrategyLedger = 2,
  MergeStrategySnapshot = 3,

}

pub const ENUM_MIN_MERGE_STRATEGY: u8 = 0;
pub const ENUM_MAX_MERGE_STRATEGY: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for MergeStrategy {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for MergeStrategy {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const MergeStrategy;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const MergeStrategy;
    unsafe { *p }
  }
}

impl flatbuffers::Push for MergeStrategy {
    type Output = MergeStrategy;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<MergeStrategy>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MERGE_STRATEGY:[MergeStrategy; 4] = [
  MergeStrategy::NONE,
  MergeStrategy::MergeStrategyAppend,
  MergeStrategy::MergeStrategyLedger,
  MergeStrategy::MergeStrategySnapshot
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_MERGE_STRATEGY:[&'static str; 4] = [
    "NONE",
    "MergeStrategyAppend",
    "MergeStrategyLedger",
    "MergeStrategySnapshot"
];

pub fn enum_name_merge_strategy(e: MergeStrategy) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_MERGE_STRATEGY[index as usize]
}

pub struct MergeStrategyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DatasetSource {
  NONE = 0,
  DatasetSourceRoot = 1,
  DatasetSourceDerivative = 2,

}

pub const ENUM_MIN_DATASET_SOURCE: u8 = 0;
pub const ENUM_MAX_DATASET_SOURCE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for DatasetSource {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DatasetSource {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const DatasetSource;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const DatasetSource;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DatasetSource {
    type Output = DatasetSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DatasetSource>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATASET_SOURCE:[DatasetSource; 3] = [
  DatasetSource::NONE,
  DatasetSource::DatasetSourceRoot,
  DatasetSource::DatasetSourceDerivative
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DATASET_SOURCE:[&'static str; 3] = [
    "NONE",
    "DatasetSourceRoot",
    "DatasetSourceDerivative"
];

pub fn enum_name_dataset_source(e: DatasetSource) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_DATASET_SOURCE[index as usize]
}

pub struct DatasetSourceUnionTableOffset {}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// struct Option_bool, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Option_bool {
  value_: bool,
} // pub struct Option_bool
impl flatbuffers::SafeSliceAccess for Option_bool {}
impl<'a> flatbuffers::Follow<'a> for Option_bool {
  type Inner = &'a Option_bool;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Option_bool>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Option_bool {
  type Inner = &'a Option_bool;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Option_bool>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Option_bool {
    type Output = Option_bool;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Option_bool as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Option_bool {
    type Output = Option_bool;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Option_bool as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Option_bool {
  pub fn new<'a>(_value: bool) -> Self {
    Option_bool {
      value_: _value.to_little_endian(),

    }
  }
  pub fn value<'a>(&'a self) -> bool {
    self.value_.from_little_endian()
  }
}

// struct Option_int64, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Option_int64 {
  value_: i64,
} // pub struct Option_int64
impl flatbuffers::SafeSliceAccess for Option_int64 {}
impl<'a> flatbuffers::Follow<'a> for Option_int64 {
  type Inner = &'a Option_int64;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Option_int64>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Option_int64 {
  type Inner = &'a Option_int64;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Option_int64>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Option_int64 {
    type Output = Option_int64;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Option_int64 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Option_int64 {
    type Output = Option_int64;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Option_int64 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Option_int64 {
  pub fn new<'a>(_value: i64) -> Self {
    Option_int64 {
      value_: _value.to_little_endian(),

    }
  }
  pub fn value<'a>(&'a self) -> i64 {
    self.value_.from_little_endian()
  }
}

// struct Timestamp, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Timestamp {
  year_: i32,
  ordinal_: u16,
  padding0__: u16,
  seconds_from_midnight_: u32,
  nanoseconds_: u32,
} // pub struct Timestamp
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Timestamp {
  pub fn new<'a>(_year: i32, _ordinal: u16, _seconds_from_midnight: u32, _nanoseconds: u32) -> Self {
    Timestamp {
      year_: _year.to_little_endian(),
      ordinal_: _ordinal.to_little_endian(),
      seconds_from_midnight_: _seconds_from_midnight.to_little_endian(),
      nanoseconds_: _nanoseconds.to_little_endian(),

      padding0__: 0,
    }
  }
  pub fn year<'a>(&'a self) -> i32 {
    self.year_.from_little_endian()
  }
  pub fn ordinal<'a>(&'a self) -> u16 {
    self.ordinal_.from_little_endian()
  }
  pub fn seconds_from_midnight<'a>(&'a self) -> u32 {
    self.seconds_from_midnight_.from_little_endian()
  }
  pub fn nanoseconds<'a>(&'a self) -> u32 {
    self.nanoseconds_.from_little_endian()
  }
}

// struct TimeInterval, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct TimeInterval {
  type__: TimeIntervalType,
  padding0__: u8,  padding1__: u16,
  left_: Timestamp,
  right_: Timestamp,
} // pub struct TimeInterval
impl flatbuffers::SafeSliceAccess for TimeInterval {}
impl<'a> flatbuffers::Follow<'a> for TimeInterval {
  type Inner = &'a TimeInterval;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a TimeInterval>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a TimeInterval {
  type Inner = &'a TimeInterval;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<TimeInterval>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for TimeInterval {
    type Output = TimeInterval;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const TimeInterval as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b TimeInterval {
    type Output = TimeInterval;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const TimeInterval as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl TimeInterval {
  pub fn new<'a>(_type_: TimeIntervalType, _left: &'a Timestamp, _right: &'a Timestamp) -> Self {
    TimeInterval {
      type__: _type_.to_little_endian(),
      left_: *_left,
      right_: *_right,

      padding0__: 0,padding1__: 0,
    }
  }
  pub fn type_<'a>(&'a self) -> TimeIntervalType {
    self.type__.from_little_endian()
  }
  pub fn left<'a>(&'a self) -> &'a Timestamp {
    &self.left_
  }
  pub fn right<'a>(&'a self) -> &'a Timestamp {
    &self.right_
  }
}

// struct Option_SourceOrdering, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Option_SourceOrdering {
  value_: SourceOrdering,
} // pub struct Option_SourceOrdering
impl flatbuffers::SafeSliceAccess for Option_SourceOrdering {}
impl<'a> flatbuffers::Follow<'a> for Option_SourceOrdering {
  type Inner = &'a Option_SourceOrdering;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Option_SourceOrdering>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Option_SourceOrdering {
  type Inner = &'a Option_SourceOrdering;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Option_SourceOrdering>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Option_SourceOrdering {
    type Output = Option_SourceOrdering;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Option_SourceOrdering as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Option_SourceOrdering {
    type Output = Option_SourceOrdering;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Option_SourceOrdering as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Option_SourceOrdering {
  pub fn new<'a>(_value: SourceOrdering) -> Self {
    Option_SourceOrdering {
      value_: _value.to_little_endian(),

    }
  }
  pub fn value<'a>(&'a self) -> SourceOrdering {
    self.value_.from_little_endian()
  }
}

// struct Option_CompressionFormat, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Option_CompressionFormat {
  value_: CompressionFormat,
} // pub struct Option_CompressionFormat
impl flatbuffers::SafeSliceAccess for Option_CompressionFormat {}
impl<'a> flatbuffers::Follow<'a> for Option_CompressionFormat {
  type Inner = &'a Option_CompressionFormat;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Option_CompressionFormat>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Option_CompressionFormat {
  type Inner = &'a Option_CompressionFormat;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Option_CompressionFormat>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Option_CompressionFormat {
    type Output = Option_CompressionFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Option_CompressionFormat as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Option_CompressionFormat {
    type Output = Option_CompressionFormat;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Option_CompressionFormat as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Option_CompressionFormat {
  pub fn new<'a>(_value: CompressionFormat) -> Self {
    Option_CompressionFormat {
      value_: _value.to_little_endian(),

    }
  }
  pub fn value<'a>(&'a self) -> CompressionFormat {
    self.value_.from_little_endian()
  }
}

pub enum EventTimeSourceFromMetadataOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromMetadata<'a> {
    type Inner = EventTimeSourceFromMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EventTimeSourceFromMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromMetadata {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args EventTimeSourceFromMetadataArgs) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'bldr>> {
      let mut builder = EventTimeSourceFromMetadataBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct EventTimeSourceFromMetadataArgs {
}
impl<'a> Default for EventTimeSourceFromMetadataArgs {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromMetadataArgs {
        }
    }
}
pub struct EventTimeSourceFromMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventTimeSourceFromMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventTimeSourceFromMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EventTimeSourceFromPathOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EventTimeSourceFromPath<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromPath<'a> {
    type Inner = EventTimeSourceFromPath<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EventTimeSourceFromPath<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromPath {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EventTimeSourceFromPathArgs<'args>) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'bldr>> {
      let mut builder = EventTimeSourceFromPathBuilder::new(_fbb);
      if let Some(x) = args.timestamp_format { builder.add_timestamp_format(x); }
      if let Some(x) = args.pattern { builder.add_pattern(x); }
      builder.finish()
    }

    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn pattern(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventTimeSourceFromPath::VT_PATTERN, None)
  }
  #[inline]
  pub fn timestamp_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT, None)
  }
}

pub struct EventTimeSourceFromPathArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for EventTimeSourceFromPathArgs<'a> {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromPathArgs {
            pattern: None,
            timestamp_format: None,
        }
    }
}
pub struct EventTimeSourceFromPathBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromPathBuilder<'a, 'b> {
  #[inline]
  pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventTimeSourceFromPath::VT_PATTERN, pattern);
  }
  #[inline]
  pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT, timestamp_format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventTimeSourceFromPathBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventTimeSourceFromPathBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SourceCachingForeverOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SourceCachingForever<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceCachingForever<'a> {
    type Inner = SourceCachingForever<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SourceCachingForever<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceCachingForever {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args SourceCachingForeverArgs) -> flatbuffers::WIPOffset<SourceCachingForever<'bldr>> {
      let mut builder = SourceCachingForeverBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct SourceCachingForeverArgs {
}
impl<'a> Default for SourceCachingForeverArgs {
    #[inline]
    fn default() -> Self {
        SourceCachingForeverArgs {
        }
    }
}
pub struct SourceCachingForeverBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SourceCachingForeverBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SourceCachingForeverBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SourceCachingForeverBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SourceCachingForever<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchStepUrlOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepUrl<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepUrl<'a> {
    type Inner = FetchStepUrl<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FetchStepUrl<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepUrl {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepUrlArgs<'args>) -> flatbuffers::WIPOffset<FetchStepUrl<'bldr>> {
      let mut builder = FetchStepUrlBuilder::new(_fbb);
      if let Some(x) = args.cache { builder.add_cache(x); }
      if let Some(x) = args.event_time { builder.add_event_time(x); }
      if let Some(x) = args.url { builder.add_url(x); }
      builder.add_cache_type(args.cache_type);
      builder.add_event_time_type(args.event_time_type);
      builder.finish()
    }

    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepUrl::VT_URL, None)
  }
  #[inline]
  pub fn event_time_type(&self) -> EventTimeSource {
    self._tab.get::<EventTimeSource>(FetchStepUrl::VT_EVENT_TIME_TYPE, Some(EventTimeSource::NONE)).unwrap()
  }
  #[inline]
  pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FetchStepUrl::VT_EVENT_TIME, None)
  }
  #[inline]
  pub fn cache_type(&self) -> SourceCaching {
    self._tab.get::<SourceCaching>(FetchStepUrl::VT_CACHE_TYPE, Some(SourceCaching::NONE)).unwrap()
  }
  #[inline]
  pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FetchStepUrl::VT_CACHE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_time_as_event_time_source_from_metadata(&self) -> Option<EventTimeSourceFromMetadata<'a>> {
    if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
      self.event_time().map(|u| EventTimeSourceFromMetadata::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
    if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
      self.event_time().map(|u| EventTimeSourceFromPath::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
    if self.cache_type() == SourceCaching::SourceCachingForever {
      self.cache().map(|u| SourceCachingForever::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct FetchStepUrlArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FetchStepUrlArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepUrlArgs {
            url: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
        }
    }
}
pub struct FetchStepUrlBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepUrlBuilder<'a, 'b> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_URL, url);
  }
  #[inline]
  pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
    self.fbb_.push_slot::<EventTimeSource>(FetchStepUrl::VT_EVENT_TIME_TYPE, event_time_type, EventTimeSource::NONE);
  }
  #[inline]
  pub fn add_event_time(&mut self, event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_EVENT_TIME, event_time);
  }
  #[inline]
  pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
    self.fbb_.push_slot::<SourceCaching>(FetchStepUrl::VT_CACHE_TYPE, cache_type, SourceCaching::NONE);
  }
  #[inline]
  pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_CACHE, cache);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FetchStepUrlBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchStepUrlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepUrl<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FetchStepFilesGlobOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FetchStepFilesGlob<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepFilesGlob<'a> {
    type Inner = FetchStepFilesGlob<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FetchStepFilesGlob<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepFilesGlob {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepFilesGlobArgs<'args>) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'bldr>> {
      let mut builder = FetchStepFilesGlobBuilder::new(_fbb);
      if let Some(x) = args.order { builder.add_order(x); }
      if let Some(x) = args.cache { builder.add_cache(x); }
      if let Some(x) = args.event_time { builder.add_event_time(x); }
      if let Some(x) = args.path { builder.add_path(x); }
      builder.add_cache_type(args.cache_type);
      builder.add_event_time_type(args.event_time_type);
      builder.finish()
    }

    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;
    pub const VT_ORDER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepFilesGlob::VT_PATH, None)
  }
  #[inline]
  pub fn event_time_type(&self) -> EventTimeSource {
    self._tab.get::<EventTimeSource>(FetchStepFilesGlob::VT_EVENT_TIME_TYPE, Some(EventTimeSource::NONE)).unwrap()
  }
  #[inline]
  pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FetchStepFilesGlob::VT_EVENT_TIME, None)
  }
  #[inline]
  pub fn cache_type(&self) -> SourceCaching {
    self._tab.get::<SourceCaching>(FetchStepFilesGlob::VT_CACHE_TYPE, Some(SourceCaching::NONE)).unwrap()
  }
  #[inline]
  pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FetchStepFilesGlob::VT_CACHE, None)
  }
  #[inline]
  pub fn order(&self) -> Option<&'a Option_SourceOrdering> {
    self._tab.get::<Option_SourceOrdering>(FetchStepFilesGlob::VT_ORDER, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_time_as_event_time_source_from_metadata(&self) -> Option<EventTimeSourceFromMetadata<'a>> {
    if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
      self.event_time().map(|u| EventTimeSourceFromMetadata::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
    if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
      self.event_time().map(|u| EventTimeSourceFromPath::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
    if self.cache_type() == SourceCaching::SourceCachingForever {
      self.cache().map(|u| SourceCachingForever::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct FetchStepFilesGlobArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub order: Option<&'a  Option_SourceOrdering>,
}
impl<'a> Default for FetchStepFilesGlobArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepFilesGlobArgs {
            path: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
            order: None,
        }
    }
}
pub struct FetchStepFilesGlobBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepFilesGlobBuilder<'a, 'b> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_PATH, path);
  }
  #[inline]
  pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
    self.fbb_.push_slot::<EventTimeSource>(FetchStepFilesGlob::VT_EVENT_TIME_TYPE, event_time_type, EventTimeSource::NONE);
  }
  #[inline]
  pub fn add_event_time(&mut self, event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_EVENT_TIME, event_time);
  }
  #[inline]
  pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
    self.fbb_.push_slot::<SourceCaching>(FetchStepFilesGlob::VT_CACHE_TYPE, cache_type, SourceCaching::NONE);
  }
  #[inline]
  pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_CACHE, cache);
  }
  #[inline]
  pub fn add_order(&mut self, order: &'b  Option_SourceOrdering) {
    self.fbb_.push_slot_always::<&Option_SourceOrdering>(FetchStepFilesGlob::VT_ORDER, order);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FetchStepFilesGlobBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FetchStepFilesGlobBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PrepStepDecompressOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PrepStepDecompress<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepDecompress<'a> {
    type Inner = PrepStepDecompress<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PrepStepDecompress<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepDecompress {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepDecompressArgs<'args>) -> flatbuffers::WIPOffset<PrepStepDecompress<'bldr>> {
      let mut builder = PrepStepDecompressBuilder::new(_fbb);
      if let Some(x) = args.sub_path { builder.add_sub_path(x); }
      if let Some(x) = args.format { builder.add_format(x); }
      builder.finish()
    }

    pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn format(&self) -> Option<&'a Option_CompressionFormat> {
    self._tab.get::<Option_CompressionFormat>(PrepStepDecompress::VT_FORMAT, None)
  }
  #[inline]
  pub fn sub_path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PrepStepDecompress::VT_SUB_PATH, None)
  }
}

pub struct PrepStepDecompressArgs<'a> {
    pub format: Option<&'a  Option_CompressionFormat>,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for PrepStepDecompressArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepDecompressArgs {
            format: None,
            sub_path: None,
        }
    }
}
pub struct PrepStepDecompressBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepDecompressBuilder<'a, 'b> {
  #[inline]
  pub fn add_format(&mut self, format: &'b  Option_CompressionFormat) {
    self.fbb_.push_slot_always::<&Option_CompressionFormat>(PrepStepDecompress::VT_FORMAT, format);
  }
  #[inline]
  pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepDecompress::VT_SUB_PATH, sub_path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepDecompressBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrepStepDecompressBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepDecompress<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PrepStepPipeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PrepStepPipe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepPipe<'a> {
    type Inner = PrepStepPipe<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PrepStepPipe<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepPipe {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepPipeArgs<'args>) -> flatbuffers::WIPOffset<PrepStepPipe<'bldr>> {
      let mut builder = PrepStepPipeBuilder::new(_fbb);
      if let Some(x) = args.command { builder.add_command(x); }
      builder.finish()
    }

    pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn command(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(PrepStepPipe::VT_COMMAND, None)
  }
}

pub struct PrepStepPipeArgs<'a> {
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for PrepStepPipeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepPipeArgs {
            command: None,
        }
    }
}
pub struct PrepStepPipeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepPipeBuilder<'a, 'b> {
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepPipe::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepPipeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrepStepPipeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepPipe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadStepCsvOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepCsv<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepCsv<'a> {
    type Inner = ReadStepCsv<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReadStepCsv<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepCsv {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepCsvArgs<'args>) -> flatbuffers::WIPOffset<ReadStepCsv<'bldr>> {
      let mut builder = ReadStepCsvBuilder::new(_fbb);
      if let Some(x) = args.multi_line { builder.add_multi_line(x); }
      if let Some(x) = args.timestamp_format { builder.add_timestamp_format(x); }
      if let Some(x) = args.date_format { builder.add_date_format(x); }
      if let Some(x) = args.negative_inf { builder.add_negative_inf(x); }
      if let Some(x) = args.positive_inf { builder.add_positive_inf(x); }
      if let Some(x) = args.nan_value { builder.add_nan_value(x); }
      if let Some(x) = args.empty_value { builder.add_empty_value(x); }
      if let Some(x) = args.null_value { builder.add_null_value(x); }
      if let Some(x) = args.ignore_trailing_white_space { builder.add_ignore_trailing_white_space(x); }
      if let Some(x) = args.ignore_leading_white_space { builder.add_ignore_leading_white_space(x); }
      if let Some(x) = args.infer_schema { builder.add_infer_schema(x); }
      if let Some(x) = args.enforce_schema { builder.add_enforce_schema(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      if let Some(x) = args.comment { builder.add_comment(x); }
      if let Some(x) = args.escape { builder.add_escape(x); }
      if let Some(x) = args.quote { builder.add_quote(x); }
      if let Some(x) = args.encoding { builder.add_encoding(x); }
      if let Some(x) = args.separator { builder.add_separator(x); }
      if let Some(x) = args.schema { builder.add_schema(x); }
      builder.finish()
    }

    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SEPARATOR: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_QUOTE: flatbuffers::VOffsetT = 10;
    pub const VT_ESCAPE: flatbuffers::VOffsetT = 12;
    pub const VT_COMMENT: flatbuffers::VOffsetT = 14;
    pub const VT_HEADER: flatbuffers::VOffsetT = 16;
    pub const VT_ENFORCE_SCHEMA: flatbuffers::VOffsetT = 18;
    pub const VT_INFER_SCHEMA: flatbuffers::VOffsetT = 20;
    pub const VT_IGNORE_LEADING_WHITE_SPACE: flatbuffers::VOffsetT = 22;
    pub const VT_IGNORE_TRAILING_WHITE_SPACE: flatbuffers::VOffsetT = 24;
    pub const VT_NULL_VALUE: flatbuffers::VOffsetT = 26;
    pub const VT_EMPTY_VALUE: flatbuffers::VOffsetT = 28;
    pub const VT_NAN_VALUE: flatbuffers::VOffsetT = 30;
    pub const VT_POSITIVE_INF: flatbuffers::VOffsetT = 32;
    pub const VT_NEGATIVE_INF: flatbuffers::VOffsetT = 34;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 36;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 38;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 40;

  #[inline]
  pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(ReadStepCsv::VT_SCHEMA, None)
  }
  #[inline]
  pub fn separator(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_SEPARATOR, None)
  }
  #[inline]
  pub fn encoding(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ENCODING, None)
  }
  #[inline]
  pub fn quote(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_QUOTE, None)
  }
  #[inline]
  pub fn escape(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ESCAPE, None)
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_COMMENT, None)
  }
  #[inline]
  pub fn header(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_HEADER, None)
  }
  #[inline]
  pub fn enforce_schema(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, None)
  }
  #[inline]
  pub fn infer_schema(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_INFER_SCHEMA, None)
  }
  #[inline]
  pub fn ignore_leading_white_space(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE, None)
  }
  #[inline]
  pub fn ignore_trailing_white_space(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE, None)
  }
  #[inline]
  pub fn null_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NULL_VALUE, None)
  }
  #[inline]
  pub fn empty_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_EMPTY_VALUE, None)
  }
  #[inline]
  pub fn nan_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NAN_VALUE, None)
  }
  #[inline]
  pub fn positive_inf(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_POSITIVE_INF, None)
  }
  #[inline]
  pub fn negative_inf(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NEGATIVE_INF, None)
  }
  #[inline]
  pub fn date_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_DATE_FORMAT, None)
  }
  #[inline]
  pub fn timestamp_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_TIMESTAMP_FORMAT, None)
  }
  #[inline]
  pub fn multi_line(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepCsv::VT_MULTI_LINE, None)
  }
}

pub struct ReadStepCsvArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub separator: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub quote: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub escape: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub header: Option<&'a  Option_bool>,
    pub enforce_schema: Option<&'a  Option_bool>,
    pub infer_schema: Option<&'a  Option_bool>,
    pub ignore_leading_white_space: Option<&'a  Option_bool>,
    pub ignore_trailing_white_space: Option<&'a  Option_bool>,
    pub null_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub empty_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub nan_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub positive_inf: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub negative_inf: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub date_format: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub multi_line: Option<&'a  Option_bool>,
}
impl<'a> Default for ReadStepCsvArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepCsvArgs {
            schema: None,
            separator: None,
            encoding: None,
            quote: None,
            escape: None,
            comment: None,
            header: None,
            enforce_schema: None,
            infer_schema: None,
            ignore_leading_white_space: None,
            ignore_trailing_white_space: None,
            null_value: None,
            empty_value: None,
            nan_value: None,
            positive_inf: None,
            negative_inf: None,
            date_format: None,
            timestamp_format: None,
            multi_line: None,
        }
    }
}
pub struct ReadStepCsvBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepCsvBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_separator(&mut self, separator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SEPARATOR, separator);
  }
  #[inline]
  pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ENCODING, encoding);
  }
  #[inline]
  pub fn add_quote(&mut self, quote: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_QUOTE, quote);
  }
  #[inline]
  pub fn add_escape(&mut self, escape: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ESCAPE, escape);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_header(&mut self, header: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_HEADER, header);
  }
  #[inline]
  pub fn add_enforce_schema(&mut self, enforce_schema: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, enforce_schema);
  }
  #[inline]
  pub fn add_infer_schema(&mut self, infer_schema: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_INFER_SCHEMA, infer_schema);
  }
  #[inline]
  pub fn add_ignore_leading_white_space(&mut self, ignore_leading_white_space: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE, ignore_leading_white_space);
  }
  #[inline]
  pub fn add_ignore_trailing_white_space(&mut self, ignore_trailing_white_space: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE, ignore_trailing_white_space);
  }
  #[inline]
  pub fn add_null_value(&mut self, null_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NULL_VALUE, null_value);
  }
  #[inline]
  pub fn add_empty_value(&mut self, empty_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_EMPTY_VALUE, empty_value);
  }
  #[inline]
  pub fn add_nan_value(&mut self, nan_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NAN_VALUE, nan_value);
  }
  #[inline]
  pub fn add_positive_inf(&mut self, positive_inf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_POSITIVE_INF, positive_inf);
  }
  #[inline]
  pub fn add_negative_inf(&mut self, negative_inf: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NEGATIVE_INF, negative_inf);
  }
  #[inline]
  pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_DATE_FORMAT, date_format);
  }
  #[inline]
  pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_TIMESTAMP_FORMAT, timestamp_format);
  }
  #[inline]
  pub fn add_multi_line(&mut self, multi_line: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepCsv::VT_MULTI_LINE, multi_line);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepCsvBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadStepCsvBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepCsv<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadStepJsonLinesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadStepJsonLines<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepJsonLines<'a> {
    type Inner = ReadStepJsonLines<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReadStepJsonLines<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepJsonLines {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepJsonLinesArgs<'args>) -> flatbuffers::WIPOffset<ReadStepJsonLines<'bldr>> {
      let mut builder = ReadStepJsonLinesBuilder::new(_fbb);
      if let Some(x) = args.timestamp_format { builder.add_timestamp_format(x); }
      if let Some(x) = args.primitives_as_string { builder.add_primitives_as_string(x); }
      if let Some(x) = args.multi_line { builder.add_multi_line(x); }
      if let Some(x) = args.encoding { builder.add_encoding(x); }
      if let Some(x) = args.date_format { builder.add_date_format(x); }
      if let Some(x) = args.schema { builder.add_schema(x); }
      builder.finish()
    }

    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 10;
    pub const VT_PRIMITIVES_AS_STRING: flatbuffers::VOffsetT = 12;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(ReadStepJsonLines::VT_SCHEMA, None)
  }
  #[inline]
  pub fn date_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_DATE_FORMAT, None)
  }
  #[inline]
  pub fn encoding(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_ENCODING, None)
  }
  #[inline]
  pub fn multi_line(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepJsonLines::VT_MULTI_LINE, None)
  }
  #[inline]
  pub fn primitives_as_string(&self) -> Option<&'a Option_bool> {
    self._tab.get::<Option_bool>(ReadStepJsonLines::VT_PRIMITIVES_AS_STRING, None)
  }
  #[inline]
  pub fn timestamp_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_TIMESTAMP_FORMAT, None)
  }
}

pub struct ReadStepJsonLinesArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub date_format: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub multi_line: Option<&'a  Option_bool>,
    pub primitives_as_string: Option<&'a  Option_bool>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for ReadStepJsonLinesArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepJsonLinesArgs {
            schema: None,
            date_format: None,
            encoding: None,
            multi_line: None,
            primitives_as_string: None,
            timestamp_format: None,
        }
    }
}
pub struct ReadStepJsonLinesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepJsonLinesBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_DATE_FORMAT, date_format);
  }
  #[inline]
  pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_ENCODING, encoding);
  }
  #[inline]
  pub fn add_multi_line(&mut self, multi_line: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepJsonLines::VT_MULTI_LINE, multi_line);
  }
  #[inline]
  pub fn add_primitives_as_string(&mut self, primitives_as_string: &'b  Option_bool) {
    self.fbb_.push_slot_always::<&Option_bool>(ReadStepJsonLines::VT_PRIMITIVES_AS_STRING, primitives_as_string);
  }
  #[inline]
  pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_TIMESTAMP_FORMAT, timestamp_format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepJsonLinesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadStepJsonLinesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepJsonLines<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadStepGeoJsonOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadStepGeoJson<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepGeoJson<'a> {
    type Inner = ReadStepGeoJson<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReadStepGeoJson<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepGeoJson {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepGeoJsonArgs<'args>) -> flatbuffers::WIPOffset<ReadStepGeoJson<'bldr>> {
      let mut builder = ReadStepGeoJsonBuilder::new(_fbb);
      if let Some(x) = args.schema { builder.add_schema(x); }
      builder.finish()
    }

    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(ReadStepGeoJson::VT_SCHEMA, None)
  }
}

pub struct ReadStepGeoJsonArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for ReadStepGeoJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepGeoJsonArgs {
            schema: None,
        }
    }
}
pub struct ReadStepGeoJsonBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepGeoJsonBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepGeoJson::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepGeoJsonBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadStepGeoJsonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepGeoJson<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReadStepEsriShapefileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReadStepEsriShapefile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepEsriShapefile<'a> {
    type Inner = ReadStepEsriShapefile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReadStepEsriShapefile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepEsriShapefile {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepEsriShapefileArgs<'args>) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'bldr>> {
      let mut builder = ReadStepEsriShapefileBuilder::new(_fbb);
      if let Some(x) = args.sub_path { builder.add_sub_path(x); }
      if let Some(x) = args.schema { builder.add_schema(x); }
      builder.finish()
    }

    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(ReadStepEsriShapefile::VT_SCHEMA, None)
  }
  #[inline]
  pub fn sub_path(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepEsriShapefile::VT_SUB_PATH, None)
  }
}

pub struct ReadStepEsriShapefileArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for ReadStepEsriShapefileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepEsriShapefileArgs {
            schema: None,
            sub_path: None,
        }
    }
}
pub struct ReadStepEsriShapefileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepEsriShapefileBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepEsriShapefile::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepEsriShapefile::VT_SUB_PATH, sub_path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepEsriShapefileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadStepEsriShapefileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransformSqlOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TransformSql<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformSql<'a> {
    type Inner = TransformSql<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TransformSql<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformSql {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransformSqlArgs<'args>) -> flatbuffers::WIPOffset<TransformSql<'bldr>> {
      let mut builder = TransformSqlBuilder::new(_fbb);
      if let Some(x) = args.temporal_tables { builder.add_temporal_tables(x); }
      if let Some(x) = args.queries { builder.add_queries(x); }
      if let Some(x) = args.query { builder.add_query(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      if let Some(x) = args.engine { builder.add_engine(x); }
      builder.finish()
    }

    pub const VT_ENGINE: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_QUERY: flatbuffers::VOffsetT = 8;
    pub const VT_QUERIES: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPORAL_TABLES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn engine(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_ENGINE, None)
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_VERSION, None)
  }
  #[inline]
  pub fn query(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_QUERY, None)
  }
  #[inline]
  pub fn queries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>>>(TransformSql::VT_QUERIES, None)
  }
  #[inline]
  pub fn temporal_tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TemporalTable<'a>>>>>(TransformSql::VT_TEMPORAL_TABLES, None)
  }
}

pub struct TransformSqlArgs<'a> {
    pub engine: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub queries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<SqlQueryStep<'a >>>>>,
    pub temporal_tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<TemporalTable<'a >>>>>,
}
impl<'a> Default for TransformSqlArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformSqlArgs {
            engine: None,
            version: None,
            query: None,
            queries: None,
            temporal_tables: None,
        }
    }
}
pub struct TransformSqlBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformSqlBuilder<'a, 'b> {
  #[inline]
  pub fn add_engine(&mut self, engine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_ENGINE, engine);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_VERSION, version);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERY, query);
  }
  #[inline]
  pub fn add_queries(&mut self, queries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SqlQueryStep<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERIES, queries);
  }
  #[inline]
  pub fn add_temporal_tables(&mut self, temporal_tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TemporalTable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_TEMPORAL_TABLES, temporal_tables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformSqlBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransformSqlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransformSql<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MergeStrategyAppendOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategyAppend<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyAppend<'a> {
    type Inner = MergeStrategyAppend<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MergeStrategyAppend<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyAppend {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MergeStrategyAppendArgs) -> flatbuffers::WIPOffset<MergeStrategyAppend<'bldr>> {
      let mut builder = MergeStrategyAppendBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct MergeStrategyAppendArgs {
}
impl<'a> Default for MergeStrategyAppendArgs {
    #[inline]
    fn default() -> Self {
        MergeStrategyAppendArgs {
        }
    }
}
pub struct MergeStrategyAppendBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyAppendBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MergeStrategyAppendBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MergeStrategyAppendBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyAppend<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MergeStrategyLedgerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MergeStrategyLedger<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyLedger<'a> {
    type Inner = MergeStrategyLedger<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MergeStrategyLedger<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyLedger {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategyLedgerArgs<'args>) -> flatbuffers::WIPOffset<MergeStrategyLedger<'bldr>> {
      let mut builder = MergeStrategyLedgerBuilder::new(_fbb);
      if let Some(x) = args.primary_key { builder.add_primary_key(x); }
      builder.finish()
    }

    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn primary_key(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(MergeStrategyLedger::VT_PRIMARY_KEY, None)
  }
}

pub struct MergeStrategyLedgerArgs<'a> {
    pub primary_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for MergeStrategyLedgerArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategyLedgerArgs {
            primary_key: None,
        }
    }
}
pub struct MergeStrategyLedgerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyLedgerBuilder<'a, 'b> {
  #[inline]
  pub fn add_primary_key(&mut self, primary_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategyLedger::VT_PRIMARY_KEY, primary_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MergeStrategyLedgerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MergeStrategyLedgerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyLedger<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MergeStrategySnapshotOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MergeStrategySnapshot<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategySnapshot<'a> {
    type Inner = MergeStrategySnapshot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MergeStrategySnapshot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategySnapshot {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategySnapshotArgs<'args>) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'bldr>> {
      let mut builder = MergeStrategySnapshotBuilder::new(_fbb);
      if let Some(x) = args.obsv_removed { builder.add_obsv_removed(x); }
      if let Some(x) = args.obsv_changed { builder.add_obsv_changed(x); }
      if let Some(x) = args.obsv_added { builder.add_obsv_added(x); }
      if let Some(x) = args.observation_column { builder.add_observation_column(x); }
      if let Some(x) = args.compare_columns { builder.add_compare_columns(x); }
      if let Some(x) = args.primary_key { builder.add_primary_key(x); }
      builder.finish()
    }

    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_COMPARE_COLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_OBSERVATION_COLUMN: flatbuffers::VOffsetT = 8;
    pub const VT_OBSV_ADDED: flatbuffers::VOffsetT = 10;
    pub const VT_OBSV_CHANGED: flatbuffers::VOffsetT = 12;
    pub const VT_OBSV_REMOVED: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn primary_key(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(MergeStrategySnapshot::VT_PRIMARY_KEY, None)
  }
  #[inline]
  pub fn compare_columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(MergeStrategySnapshot::VT_COMPARE_COLUMNS, None)
  }
  #[inline]
  pub fn observation_column(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSERVATION_COLUMN, None)
  }
  #[inline]
  pub fn obsv_added(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_ADDED, None)
  }
  #[inline]
  pub fn obsv_changed(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_CHANGED, None)
  }
  #[inline]
  pub fn obsv_removed(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_REMOVED, None)
  }
}

pub struct MergeStrategySnapshotArgs<'a> {
    pub primary_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub compare_columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub observation_column: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub obsv_added: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub obsv_changed: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub obsv_removed: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for MergeStrategySnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategySnapshotArgs {
            primary_key: None,
            compare_columns: None,
            observation_column: None,
            obsv_added: None,
            obsv_changed: None,
            obsv_removed: None,
        }
    }
}
pub struct MergeStrategySnapshotBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategySnapshotBuilder<'a, 'b> {
  #[inline]
  pub fn add_primary_key(&mut self, primary_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_PRIMARY_KEY, primary_key);
  }
  #[inline]
  pub fn add_compare_columns(&mut self, compare_columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_COMPARE_COLUMNS, compare_columns);
  }
  #[inline]
  pub fn add_observation_column(&mut self, observation_column: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_OBSERVATION_COLUMN, observation_column);
  }
  #[inline]
  pub fn add_obsv_added(&mut self, obsv_added: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_OBSV_ADDED, obsv_added);
  }
  #[inline]
  pub fn add_obsv_changed(&mut self, obsv_changed: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_OBSV_CHANGED, obsv_changed);
  }
  #[inline]
  pub fn add_obsv_removed(&mut self, obsv_removed: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MergeStrategySnapshot::VT_OBSV_REMOVED, obsv_removed);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MergeStrategySnapshotBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MergeStrategySnapshotBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PrepStepWrapperOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct PrepStepWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepWrapper<'a> {
    type Inner = PrepStepWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PrepStepWrapper<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepWrapper {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepWrapperArgs) -> flatbuffers::WIPOffset<PrepStepWrapper<'bldr>> {
      let mut builder = PrepStepWrapperBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.add_value_type(args.value_type);
      builder.finish()
    }

    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn value_type(&self) -> PrepStep {
    self._tab.get::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, Some(PrepStep::NONE)).unwrap()
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PrepStepWrapper::VT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_prep_step_decompress(&self) -> Option<PrepStepDecompress<'a>> {
    if self.value_type() == PrepStep::PrepStepDecompress {
      self.value().map(|u| PrepStepDecompress::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_prep_step_pipe(&self) -> Option<PrepStepPipe<'a>> {
    if self.value_type() == PrepStep::PrepStepPipe {
      self.value().map(|u| PrepStepPipe::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct PrepStepWrapperArgs {
    pub value_type: PrepStep,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PrepStepWrapperArgs {
    #[inline]
    fn default() -> Self {
        PrepStepWrapperArgs {
            value_type: PrepStep::NONE,
            value: None,
        }
    }
}
pub struct PrepStepWrapperBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepWrapperBuilder<'a, 'b> {
  #[inline]
  pub fn add_value_type(&mut self, value_type: PrepStep) {
    self.fbb_.push_slot::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, value_type, PrepStep::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepWrapper::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepWrapperBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrepStepWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DatasetSourceRootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DatasetSourceRoot<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSourceRoot<'a> {
    type Inner = DatasetSourceRoot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DatasetSourceRoot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSourceRoot {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSourceRootArgs<'args>) -> flatbuffers::WIPOffset<DatasetSourceRoot<'bldr>> {
      let mut builder = DatasetSourceRootBuilder::new(_fbb);
      if let Some(x) = args.merge { builder.add_merge(x); }
      if let Some(x) = args.preprocess { builder.add_preprocess(x); }
      if let Some(x) = args.read { builder.add_read(x); }
      if let Some(x) = args.prepare { builder.add_prepare(x); }
      if let Some(x) = args.fetch { builder.add_fetch(x); }
      builder.add_merge_type(args.merge_type);
      builder.add_preprocess_type(args.preprocess_type);
      builder.add_read_type(args.read_type);
      builder.add_fetch_type(args.fetch_type);
      builder.finish()
    }

    pub const VT_FETCH_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FETCH: flatbuffers::VOffsetT = 6;
    pub const VT_PREPARE: flatbuffers::VOffsetT = 8;
    pub const VT_READ_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_READ: flatbuffers::VOffsetT = 12;
    pub const VT_PREPROCESS_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_PREPROCESS: flatbuffers::VOffsetT = 16;
    pub const VT_MERGE_TYPE: flatbuffers::VOffsetT = 18;
    pub const VT_MERGE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn fetch_type(&self) -> FetchStep {
    self._tab.get::<FetchStep>(DatasetSourceRoot::VT_FETCH_TYPE, Some(FetchStep::NONE)).unwrap()
  }
  #[inline]
  pub fn fetch(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSourceRoot::VT_FETCH, None)
  }
  #[inline]
  pub fn prepare(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>>>(DatasetSourceRoot::VT_PREPARE, None)
  }
  #[inline]
  pub fn read_type(&self) -> ReadStep {
    self._tab.get::<ReadStep>(DatasetSourceRoot::VT_READ_TYPE, Some(ReadStep::NONE)).unwrap()
  }
  #[inline]
  pub fn read(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSourceRoot::VT_READ, None)
  }
  #[inline]
  pub fn preprocess_type(&self) -> Transform {
    self._tab.get::<Transform>(DatasetSourceRoot::VT_PREPROCESS_TYPE, Some(Transform::NONE)).unwrap()
  }
  #[inline]
  pub fn preprocess(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSourceRoot::VT_PREPROCESS, None)
  }
  #[inline]
  pub fn merge_type(&self) -> MergeStrategy {
    self._tab.get::<MergeStrategy>(DatasetSourceRoot::VT_MERGE_TYPE, Some(MergeStrategy::NONE)).unwrap()
  }
  #[inline]
  pub fn merge(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSourceRoot::VT_MERGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn fetch_as_fetch_step_url(&self) -> Option<FetchStepUrl<'a>> {
    if self.fetch_type() == FetchStep::FetchStepUrl {
      self.fetch().map(|u| FetchStepUrl::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn fetch_as_fetch_step_files_glob(&self) -> Option<FetchStepFilesGlob<'a>> {
    if self.fetch_type() == FetchStep::FetchStepFilesGlob {
      self.fetch().map(|u| FetchStepFilesGlob::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn read_as_read_step_csv(&self) -> Option<ReadStepCsv<'a>> {
    if self.read_type() == ReadStep::ReadStepCsv {
      self.read().map(|u| ReadStepCsv::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn read_as_read_step_json_lines(&self) -> Option<ReadStepJsonLines<'a>> {
    if self.read_type() == ReadStep::ReadStepJsonLines {
      self.read().map(|u| ReadStepJsonLines::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn read_as_read_step_geo_json(&self) -> Option<ReadStepGeoJson<'a>> {
    if self.read_type() == ReadStep::ReadStepGeoJson {
      self.read().map(|u| ReadStepGeoJson::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn read_as_read_step_esri_shapefile(&self) -> Option<ReadStepEsriShapefile<'a>> {
    if self.read_type() == ReadStep::ReadStepEsriShapefile {
      self.read().map(|u| ReadStepEsriShapefile::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn preprocess_as_transform_sql(&self) -> Option<TransformSql<'a>> {
    if self.preprocess_type() == Transform::TransformSql {
      self.preprocess().map(|u| TransformSql::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn merge_as_merge_strategy_append(&self) -> Option<MergeStrategyAppend<'a>> {
    if self.merge_type() == MergeStrategy::MergeStrategyAppend {
      self.merge().map(|u| MergeStrategyAppend::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn merge_as_merge_strategy_ledger(&self) -> Option<MergeStrategyLedger<'a>> {
    if self.merge_type() == MergeStrategy::MergeStrategyLedger {
      self.merge().map(|u| MergeStrategyLedger::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn merge_as_merge_strategy_snapshot(&self) -> Option<MergeStrategySnapshot<'a>> {
    if self.merge_type() == MergeStrategy::MergeStrategySnapshot {
      self.merge().map(|u| MergeStrategySnapshot::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DatasetSourceRootArgs<'a> {
    pub fetch_type: FetchStep,
    pub fetch: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub prepare: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<PrepStepWrapper<'a >>>>>,
    pub read_type: ReadStep,
    pub read: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub preprocess_type: Transform,
    pub preprocess: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub merge_type: MergeStrategy,
    pub merge: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DatasetSourceRootArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSourceRootArgs {
            fetch_type: FetchStep::NONE,
            fetch: None,
            prepare: None,
            read_type: ReadStep::NONE,
            read: None,
            preprocess_type: Transform::NONE,
            preprocess: None,
            merge_type: MergeStrategy::NONE,
            merge: None,
        }
    }
}
pub struct DatasetSourceRootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSourceRootBuilder<'a, 'b> {
  #[inline]
  pub fn add_fetch_type(&mut self, fetch_type: FetchStep) {
    self.fbb_.push_slot::<FetchStep>(DatasetSourceRoot::VT_FETCH_TYPE, fetch_type, FetchStep::NONE);
  }
  #[inline]
  pub fn add_fetch(&mut self, fetch: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_FETCH, fetch);
  }
  #[inline]
  pub fn add_prepare(&mut self, prepare: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PrepStepWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_PREPARE, prepare);
  }
  #[inline]
  pub fn add_read_type(&mut self, read_type: ReadStep) {
    self.fbb_.push_slot::<ReadStep>(DatasetSourceRoot::VT_READ_TYPE, read_type, ReadStep::NONE);
  }
  #[inline]
  pub fn add_read(&mut self, read: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_READ, read);
  }
  #[inline]
  pub fn add_preprocess_type(&mut self, preprocess_type: Transform) {
    self.fbb_.push_slot::<Transform>(DatasetSourceRoot::VT_PREPROCESS_TYPE, preprocess_type, Transform::NONE);
  }
  #[inline]
  pub fn add_preprocess(&mut self, preprocess: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_PREPROCESS, preprocess);
  }
  #[inline]
  pub fn add_merge_type(&mut self, merge_type: MergeStrategy) {
    self.fbb_.push_slot::<MergeStrategy>(DatasetSourceRoot::VT_MERGE_TYPE, merge_type, MergeStrategy::NONE);
  }
  #[inline]
  pub fn add_merge(&mut self, merge: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_MERGE, merge);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatasetSourceRootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DatasetSourceRootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSourceRoot<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DatasetSourceDerivativeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DatasetSourceDerivative<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSourceDerivative<'a> {
    type Inner = DatasetSourceDerivative<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DatasetSourceDerivative<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSourceDerivative {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSourceDerivativeArgs<'args>) -> flatbuffers::WIPOffset<DatasetSourceDerivative<'bldr>> {
      let mut builder = DatasetSourceDerivativeBuilder::new(_fbb);
      if let Some(x) = args.transform { builder.add_transform(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      builder.add_transform_type(args.transform_type);
      builder.finish()
    }

    pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(DatasetSourceDerivative::VT_INPUTS, None)
  }
  #[inline]
  pub fn transform_type(&self) -> Transform {
    self._tab.get::<Transform>(DatasetSourceDerivative::VT_TRANSFORM_TYPE, Some(Transform::NONE)).unwrap()
  }
  #[inline]
  pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSourceDerivative::VT_TRANSFORM, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
    if self.transform_type() == Transform::TransformSql {
      self.transform().map(|u| TransformSql::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DatasetSourceDerivativeArgs<'a> {
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DatasetSourceDerivativeArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSourceDerivativeArgs {
            inputs: None,
            transform_type: Transform::NONE,
            transform: None,
        }
    }
}
pub struct DatasetSourceDerivativeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSourceDerivativeBuilder<'a, 'b> {
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceDerivative::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_transform_type(&mut self, transform_type: Transform) {
    self.fbb_.push_slot::<Transform>(DatasetSourceDerivative::VT_TRANSFORM_TYPE, transform_type, Transform::NONE);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceDerivative::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatasetSourceDerivativeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DatasetSourceDerivativeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSourceDerivative<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DatasetVocabularyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DatasetVocabulary<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetVocabulary<'a> {
    type Inner = DatasetVocabulary<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DatasetVocabulary<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetVocabulary {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetVocabularyArgs<'args>) -> flatbuffers::WIPOffset<DatasetVocabulary<'bldr>> {
      let mut builder = DatasetVocabularyBuilder::new(_fbb);
      if let Some(x) = args.event_time_column { builder.add_event_time_column(x); }
      if let Some(x) = args.system_time_column { builder.add_system_time_column(x); }
      builder.finish()
    }

    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn system_time_column(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DatasetVocabulary::VT_SYSTEM_TIME_COLUMN, None)
  }
  #[inline]
  pub fn event_time_column(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DatasetVocabulary::VT_EVENT_TIME_COLUMN, None)
  }
}

pub struct DatasetVocabularyArgs<'a> {
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for DatasetVocabularyArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetVocabularyArgs {
            system_time_column: None,
            event_time_column: None,
        }
    }
}
pub struct DatasetVocabularyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetVocabularyBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetVocabulary::VT_SYSTEM_TIME_COLUMN, system_time_column);
  }
  #[inline]
  pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetVocabulary::VT_EVENT_TIME_COLUMN, event_time_column);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatasetVocabularyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DatasetVocabularyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DatasetVocabulary<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TemporalTableOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TemporalTable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporalTable<'a> {
    type Inner = TemporalTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TemporalTable<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TemporalTable {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TemporalTableArgs<'args>) -> flatbuffers::WIPOffset<TemporalTable<'bldr>> {
      let mut builder = TemporalTableBuilder::new(_fbb);
      if let Some(x) = args.primary_key { builder.add_primary_key(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TemporalTable::VT_ID, None)
  }
  #[inline]
  pub fn primary_key(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(TemporalTable::VT_PRIMARY_KEY, None)
  }
}

pub struct TemporalTableArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub primary_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
}
impl<'a> Default for TemporalTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TemporalTableArgs {
            id: None,
            primary_key: None,
        }
    }
}
pub struct TemporalTableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TemporalTableBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TemporalTable::VT_ID, id);
  }
  #[inline]
  pub fn add_primary_key(&mut self, primary_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TemporalTable::VT_PRIMARY_KEY, primary_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TemporalTableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TemporalTableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TemporalTable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DatasetSnapshotOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DatasetSnapshot<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSnapshot<'a> {
    type Inner = DatasetSnapshot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DatasetSnapshot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSnapshot {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSnapshotArgs<'args>) -> flatbuffers::WIPOffset<DatasetSnapshot<'bldr>> {
      let mut builder = DatasetSnapshotBuilder::new(_fbb);
      if let Some(x) = args.vocab { builder.add_vocab(x); }
      if let Some(x) = args.source { builder.add_source(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_source_type(args.source_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DatasetSnapshot::VT_ID, None)
  }
  #[inline]
  pub fn source_type(&self) -> DatasetSource {
    self._tab.get::<DatasetSource>(DatasetSnapshot::VT_SOURCE_TYPE, Some(DatasetSource::NONE)).unwrap()
  }
  #[inline]
  pub fn source(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DatasetSnapshot::VT_SOURCE, None)
  }
  #[inline]
  pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DatasetVocabulary<'a>>>(DatasetSnapshot::VT_VOCAB, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_dataset_source_root(&self) -> Option<DatasetSourceRoot<'a>> {
    if self.source_type() == DatasetSource::DatasetSourceRoot {
      self.source().map(|u| DatasetSourceRoot::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_dataset_source_derivative(&self) -> Option<DatasetSourceDerivative<'a>> {
    if self.source_type() == DatasetSource::DatasetSourceDerivative {
      self.source().map(|u| DatasetSourceDerivative::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DatasetSnapshotArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub source_type: DatasetSource,
    pub source: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a >>>,
}
impl<'a> Default for DatasetSnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSnapshotArgs {
            id: None,
            source_type: DatasetSource::NONE,
            source: None,
            vocab: None,
        }
    }
}
pub struct DatasetSnapshotBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSnapshotBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_ID, id);
  }
  #[inline]
  pub fn add_source_type(&mut self, source_type: DatasetSource) {
    self.fbb_.push_slot::<DatasetSource>(DatasetSnapshot::VT_SOURCE_TYPE, source_type, DatasetSource::NONE);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(DatasetSnapshot::VT_VOCAB, vocab);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatasetSnapshotBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DatasetSnapshotBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSnapshot<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DataSliceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DataSlice<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSlice<'a> {
    type Inner = DataSlice<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DataSlice<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DataSlice {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DataSliceArgs<'args>) -> flatbuffers::WIPOffset<DataSlice<'bldr>> {
      let mut builder = DataSliceBuilder::new(_fbb);
      if let Some(x) = args.num_records { builder.add_num_records(x); }
      if let Some(x) = args.interval { builder.add_interval(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 6;
    pub const VT_NUM_RECORDS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataSlice::VT_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn interval(&self) -> Option<&'a TimeInterval> {
    self._tab.get::<TimeInterval>(DataSlice::VT_INTERVAL, None)
  }
  #[inline]
  pub fn num_records(&self) -> Option<&'a Option_int64> {
    self._tab.get::<Option_int64>(DataSlice::VT_NUM_RECORDS, None)
  }
}

pub struct DataSliceArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub interval: Option<&'a  TimeInterval>,
    pub num_records: Option<&'a  Option_int64>,
}
impl<'a> Default for DataSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        DataSliceArgs {
            hash: None,
            interval: None,
            num_records: None,
        }
    }
}
pub struct DataSliceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataSliceBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataSlice::VT_HASH, hash);
  }
  #[inline]
  pub fn add_interval(&mut self, interval: &'b  TimeInterval) {
    self.fbb_.push_slot_always::<&TimeInterval>(DataSlice::VT_INTERVAL, interval);
  }
  #[inline]
  pub fn add_num_records(&mut self, num_records: &'b  Option_int64) {
    self.fbb_.push_slot_always::<&Option_int64>(DataSlice::VT_NUM_RECORDS, num_records);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataSliceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataSliceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataSlice<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SqlQueryStepOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SqlQueryStep<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqlQueryStep<'a> {
    type Inner = SqlQueryStep<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SqlQueryStep<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SqlQueryStep {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SqlQueryStepArgs<'args>) -> flatbuffers::WIPOffset<SqlQueryStep<'bldr>> {
      let mut builder = SqlQueryStepBuilder::new(_fbb);
      if let Some(x) = args.query { builder.add_query(x); }
      if let Some(x) = args.alias { builder.add_alias(x); }
      builder.finish()
    }

    pub const VT_ALIAS: flatbuffers::VOffsetT = 4;
    pub const VT_QUERY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn alias(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_ALIAS, None)
  }
  #[inline]
  pub fn query(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_QUERY, None)
  }
}

pub struct SqlQueryStepArgs<'a> {
    pub alias: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for SqlQueryStepArgs<'a> {
    #[inline]
    fn default() -> Self {
        SqlQueryStepArgs {
            alias: None,
            query: None,
        }
    }
}
pub struct SqlQueryStepBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqlQueryStepBuilder<'a, 'b> {
  #[inline]
  pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_ALIAS, alias);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_QUERY, query);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqlQueryStepBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SqlQueryStepBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SqlQueryStep<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MetadataBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MetadataBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataBlock<'a> {
    type Inner = MetadataBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MetadataBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataBlockArgs<'args>) -> flatbuffers::WIPOffset<MetadataBlock<'bldr>> {
      let mut builder = MetadataBlockBuilder::new(_fbb);
      if let Some(x) = args.vocab { builder.add_vocab(x); }
      if let Some(x) = args.source { builder.add_source(x); }
      if let Some(x) = args.input_slices { builder.add_input_slices(x); }
      if let Some(x) = args.output_watermark { builder.add_output_watermark(x); }
      if let Some(x) = args.output_slice { builder.add_output_slice(x); }
      if let Some(x) = args.system_time { builder.add_system_time(x); }
      if let Some(x) = args.prev_block_hash { builder.add_prev_block_hash(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.add_source_type(args.source_type);
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUT_SLICE: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 12;
    pub const VT_INPUT_SLICES: flatbuffers::VOffsetT = 14;
    pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 16;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 18;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MetadataBlock::VT_BLOCK_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn prev_block_hash(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MetadataBlock::VT_PREV_BLOCK_HASH, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn system_time(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(MetadataBlock::VT_SYSTEM_TIME, None)
  }
  #[inline]
  pub fn output_slice(&self) -> Option<DataSlice<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DataSlice<'a>>>(MetadataBlock::VT_OUTPUT_SLICE, None)
  }
  #[inline]
  pub fn output_watermark(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(MetadataBlock::VT_OUTPUT_WATERMARK, None)
  }
  #[inline]
  pub fn input_slices(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DataSlice<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<DataSlice<'a>>>>>(MetadataBlock::VT_INPUT_SLICES, None)
  }
  #[inline]
  pub fn source_type(&self) -> DatasetSource {
    self._tab.get::<DatasetSource>(MetadataBlock::VT_SOURCE_TYPE, Some(DatasetSource::NONE)).unwrap()
  }
  #[inline]
  pub fn source(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MetadataBlock::VT_SOURCE, None)
  }
  #[inline]
  pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DatasetVocabulary<'a>>>(MetadataBlock::VT_VOCAB, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_dataset_source_root(&self) -> Option<DatasetSourceRoot<'a>> {
    if self.source_type() == DatasetSource::DatasetSourceRoot {
      self.source().map(|u| DatasetSourceRoot::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_dataset_source_derivative(&self) -> Option<DatasetSourceDerivative<'a>> {
    if self.source_type() == DatasetSource::DatasetSourceDerivative {
      self.source().map(|u| DatasetSourceDerivative::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct MetadataBlockArgs<'a> {
    pub block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub system_time: Option<&'a  Timestamp>,
    pub output_slice: Option<flatbuffers::WIPOffset<DataSlice<'a >>>,
    pub output_watermark: Option<&'a  Timestamp>,
    pub input_slices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<DataSlice<'a >>>>>,
    pub source_type: DatasetSource,
    pub source: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a >>>,
}
impl<'a> Default for MetadataBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataBlockArgs {
            block_hash: None,
            prev_block_hash: None,
            system_time: None,
            output_slice: None,
            output_watermark: None,
            input_slices: None,
            source_type: DatasetSource::NONE,
            source: None,
            vocab: None,
        }
    }
}
pub struct MetadataBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_prev_block_hash(&mut self, prev_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_PREV_BLOCK_HASH, prev_block_hash);
  }
  #[inline]
  pub fn add_system_time(&mut self, system_time: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(MetadataBlock::VT_SYSTEM_TIME, system_time);
  }
  #[inline]
  pub fn add_output_slice(&mut self, output_slice: flatbuffers::WIPOffset<DataSlice<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DataSlice>>(MetadataBlock::VT_OUTPUT_SLICE, output_slice);
  }
  #[inline]
  pub fn add_output_watermark(&mut self, output_watermark: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(MetadataBlock::VT_OUTPUT_WATERMARK, output_watermark);
  }
  #[inline]
  pub fn add_input_slices(&mut self, input_slices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DataSlice<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_INPUT_SLICES, input_slices);
  }
  #[inline]
  pub fn add_source_type(&mut self, source_type: DatasetSource) {
    self.fbb_.push_slot::<DatasetSource>(MetadataBlock::VT_SOURCE_TYPE, source_type, DatasetSource::NONE);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(MetadataBlock::VT_VOCAB, vocab);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetadataBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

